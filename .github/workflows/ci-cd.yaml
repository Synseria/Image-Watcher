# ============================================================================
# Workflow principal CI/CD (Int√©gration Continue / D√©ploiement Continu)
# ============================================================================
# Ce workflow orchestre l'ensemble du pipeline CI/CD :
# 
# PHASE 1 - Validation (TOUTES les branches) :
# 1. Build + Lint : Compilation et v√©rification du code
# 2. Tests + Coverage : Ex√©cution des tests et g√©n√©ration du rapport
#
# PHASE 2 - V√©rification de branche :
# Continue uniquement si branche = master OU dev
#
# PHASE 3 - D√©ploiement (selon branche) :
# 
# Branche DEV :
# - Build Docker avec tags : dev
#
# Branche MASTER :
# - Build Docker TOUJOURS avec tags : latest, master
# - SI marqueur v:MAJOR/MINOR/PATCH d√©tect√© dans les commits :
#   ‚Üí Calcul nouvelle version semver
#   ‚Üí Cr√©ation tag Git vx.x.x
#   ‚Üí Cr√©ation release GitHub
#   ‚Üí Ajout tags vx.x.x, vx.x, vx, stable sur LA M√äME IMAGE
#
# ============================================================================

name: CI/CD

# D√©clencheurs du workflow
on:
  push:
    branches:
      - master  # Branche principale
      - dev     # Branche de d√©veloppement
  pull_request:
    branches:
      - master  # PR vers master
      - dev     # PR vers dev

# Gestion de la concurrence pour √©viter les conflits
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Variables d'environnement globales
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ==========================================================================
  # PHASE 1 : VALIDATION (toutes les branches)
  # ==========================================================================
  
  # --------------------------------------------------------------------------
  # JOB 1 : Build + Lint
  # --------------------------------------------------------------------------
  build:
    name: Build et Lint
    uses: ./.github/workflows/build.yaml

  # --------------------------------------------------------------------------
  # JOB 2 : Tests + Coverage
  # --------------------------------------------------------------------------
  test:
    name: Tests et Coverage
    uses: ./.github/workflows/test.yaml
    needs: build
    permissions:
      contents: write

  # ==========================================================================
  # PHASE 2 : V√âRIFICATION DE BRANCHE
  # ==========================================================================
  
  # --------------------------------------------------------------------------
  # JOB 3 : Check si on doit continuer (master ou dev uniquement)
  # --------------------------------------------------------------------------
  check-branch:
    name: V√©rification de branche
    runs-on: ubuntu-latest
    needs: test
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      branch_name: ${{ steps.check.outputs.branch_name }}
    
    steps:
      - name: V√©rifier la branche
        id: check
        run: |
          # R√©cup√©ration du nom de branche selon le contexte
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BRANCH="${{ github.event.pull_request.head.ref }}"
          else
            BRANCH="${{ github.ref_name }}"
          fi
          
          echo "branch_name=$BRANCH" >> $GITHUB_OUTPUT
          
          # V√©rification si master ou dev
          if [[ "$BRANCH" == "master" || "$BRANCH" == "dev" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Branche $BRANCH : D√©ploiement autoris√©"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "‚è∏Ô∏è  Branche $BRANCH : Validation uniquement (pas de d√©ploiement)"
          fi

  # ==========================================================================
  # PHASE 3a : D√âPLOIEMENT DEV
  # ==========================================================================
  
  # --------------------------------------------------------------------------
  # JOB 4a : Build Docker pour DEV (tags: dev)
  # --------------------------------------------------------------------------
  deploy-dev:
    name: D√©ploiement DEV
    runs-on: ubuntu-latest
    needs: check-branch
    if: |
      needs.check-branch.outputs.should_deploy == 'true' &&
      needs.check-branch.outputs.branch_name == 'dev' &&
      github.event_name == 'push'
    
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: R√©cup√©ration du code
        uses: actions/checkout@v5

      - name: Configuration de QEMU
        uses: docker/setup-qemu-action@v3

      - name: Configuration de Buildx
        uses: docker/setup-buildx-action@v3

      - name: Connexion √† GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extraction des m√©tadonn√©es
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=dev
            type=sha,prefix=dev-

      - name: Build et Push Docker
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ==========================================================================
  # PHASE 3b : D√âPLOIEMENT MASTER
  # ==========================================================================
  
  # --------------------------------------------------------------------------
  # JOB 4b : Build Docker pour MASTER (tags: latest, master)
  # --------------------------------------------------------------------------
  deploy-master:
    name: D√©ploiement MASTER
    runs-on: ubuntu-latest
    needs: check-branch
    if: |
      needs.check-branch.outputs.should_deploy == 'true' &&
      needs.check-branch.outputs.branch_name == 'master' &&
      github.event_name == 'push'
    
    permissions:
      contents: write
      packages: write
    
    outputs:
      image_digest: ${{ steps.build.outputs.digest }}
      has_version_marker: ${{ steps.scan.outputs.has_marker }}
      new_version: ${{ steps.calc.outputs.new_tag }}
    
    steps:
      - name: R√©cup√©ration du code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Configuration de QEMU
        uses: docker/setup-qemu-action@v3

      - name: Configuration de Buildx
        uses: docker/setup-buildx-action@v3

      - name: Connexion √† GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extraction des m√©tadonn√©es
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=raw,value=master
            type=sha,prefix=master-

      - name: Build et Push Docker
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # -----------------------------------------------------------------------
      # D√©tection des marqueurs de version dans les commits
      # -----------------------------------------------------------------------
      - name: R√©cup√©rer les tags Git
        run: git fetch --tags --force

      - name: D√©terminer le dernier tag
        id: last
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "üìå Dernier tag : $LAST_TAG"

      - name: Scanner les commits pour marqueurs
        id: scan
        run: |
          LAST_TAG='${{ steps.last.outputs.last_tag }}'
          COMMITS=$(git log "$LAST_TAG"..HEAD --pretty=%B)
          
          echo "üìù Commits depuis $LAST_TAG :"
          echo "$COMMITS"
          echo ""
          
          MODE=""
          if echo "$COMMITS" | grep -qi 'v:MAJOR'; then 
            MODE="MAJOR"
          elif echo "$COMMITS" | grep -qi 'v:MINOR'; then 
            MODE="MINOR"
          elif echo "$COMMITS" | grep -qi 'v:PATCH'; then 
            MODE="PATCH"
          fi
          
          if [ -z "$MODE" ]; then
            echo "has_marker=false" >> $GITHUB_OUTPUT
            echo "‚è∏Ô∏è  Aucun marqueur d√©tect√©"
          else
            echo "has_marker=true" >> $GITHUB_OUTPUT
            echo "mode=$MODE" >> $GITHUB_OUTPUT
            echo "‚úÖ Marqueur d√©tect√© : v:$MODE"
          fi

      - name: Calculer la nouvelle version
        id: calc
        if: steps.scan.outputs.has_marker == 'true'
        run: |
          LAST_TAG='${{ steps.last.outputs.last_tag }}'
          MODE='${{ steps.scan.outputs.mode }}'
          
          # Extraction du pr√©fixe (v) et de la version
          PREFIX=$(echo "$LAST_TAG" | sed -E 's/^([^0-9]+).*$/\1/')
          BASE=$(echo "$LAST_TAG" | sed -E "s/^$PREFIX//")
          
          MAJOR=$(echo "$BASE" | cut -d'.' -f1)
          MINOR=$(echo "$BASE" | cut -d'.' -f2)
          PATCH=$(echo "$BASE" | cut -d'.' -f3 | sed 's/[^0-9].*$//')
          
          case "$MODE" in
            MAJOR)
              MAJOR=$((MAJOR+1))
              MINOR=0
              PATCH=0
              ;;
            MINOR)
              MINOR=$((MINOR+1))
              PATCH=0
              ;;
            PATCH)
              PATCH=$((PATCH+1))
              ;;
          esac
          
          NEW_TAG="${PREFIX}${MAJOR}.${MINOR}.${PATCH}"
          
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è  Nouvelle version : $NEW_TAG"

  # --------------------------------------------------------------------------
  # JOB 5 : Cr√©ation Release et Tags Semver
  # --------------------------------------------------------------------------
  create-release:
    name: Cr√©ation Release
    runs-on: ubuntu-latest
    needs: deploy-master
    if: needs.deploy-master.outputs.has_version_marker == 'true'
    
    permissions:
      contents: write
      packages: write
    
    steps:
      - name: R√©cup√©ration du code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Cr√©er et pousser le tag
        run: |
          NEW_TAG='${{ needs.deploy-master.outputs.new_version }}'
          
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin "$NEW_TAG"
          
          echo "‚úÖ Tag $NEW_TAG cr√©√© et pouss√©"

      - name: Cr√©er la release GitHub
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.deploy-master.outputs.new_version }}
          name: Release ${{ needs.deploy-master.outputs.new_version }}
          generate_release_notes: true
          body: |
            üöÄ **Release automatique**
            
            **Version :** ${{ needs.deploy-master.outputs.new_version }}
            **Image Docker :** `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.deploy-master.outputs.new_version }}`
            
            Cette release est associ√©e √† l'image Docker avec les tags suivants :
            - `latest`
            - `master`
            - `${{ needs.deploy-master.outputs.new_version }}`
            - `stable`
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # -----------------------------------------------------------------------
      # Ajout des tags semver sur LA M√äME IMAGE
      # -----------------------------------------------------------------------
      - name: Connexion √† GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Ajouter les tags semver √† l'image existante
        run: |
          NEW_TAG='${{ needs.deploy-master.outputs.new_version }}'
          DIGEST='${{ needs.deploy-master.outputs.image_digest }}'
          IMAGE_BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          
          # Conversion en minuscules (requis par GHCR)
          IMAGE_BASE=$(echo "$IMAGE_BASE" | tr '[:upper:]' '[:lower:]')
          
          # Extraction des composants de version (ex: v1.2.3 ‚Üí 1, 2, 3)
          VERSION=$(echo "$NEW_TAG" | sed 's/^v//')
          MAJOR=$(echo "$VERSION" | cut -d'.' -f1)
          MINOR=$(echo "$VERSION" | cut -d'.' -f2)
          
          echo "üè∑Ô∏è  Ajout des tags √† l'image $DIGEST :"
          
          # Tag complet (v1.2.3)
          docker buildx imagetools create --tag "${IMAGE_BASE}:${NEW_TAG}" "${IMAGE_BASE}@${DIGEST}"
          echo "  ‚úÖ ${NEW_TAG}"
          
          # Tag majeur.mineur (v1.2)
          docker buildx imagetools create --tag "${IMAGE_BASE}:v${MAJOR}.${MINOR}" "${IMAGE_BASE}@${DIGEST}"
          echo "  ‚úÖ v${MAJOR}.${MINOR}"
          
          # Tag majeur (v1)
          docker buildx imagetools create --tag "${IMAGE_BASE}:v${MAJOR}" "${IMAGE_BASE}@${DIGEST}"
          echo "  ‚úÖ v${MAJOR}"
          
          # Tag stable
          docker buildx imagetools create --tag "${IMAGE_BASE}:stable" "${IMAGE_BASE}@${DIGEST}"
          echo "  ‚úÖ stable"
          
          echo ""
          echo "‚úÖ Tous les tags ont √©t√© ajout√©s √† la m√™me image !"
