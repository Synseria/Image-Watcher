# ============================================================================
# Workflow principal CI/CD (Int√©gration Continue / D√©ploiement Continu)
# ============================================================================
# Ce workflow orchestre l'ensemble du pipeline CI/CD :
# 1. Compilation de l'application TypeScript
# 2. Ex√©cution des tests et v√©rifications de qualit√© du code
# 3. Versioning automatique (d√©tection marqueurs, cr√©ation tag/release)
# 4. Construction et publication de l'image Docker
#
# D√©clenchement :
# - Sur chaque pull request (pour validation)
# - Sur chaque push vers master/dev (pour d√©ploiement)
# - Sur chaque push de tag (pour release)
#
# Versioning automatique :
# - D√©tecte les marqueurs v:MAJOR, v:MINOR ou v:PATCH dans les commits
# - Cr√©e automatiquement un tag semver et une release GitHub
# - D√©clenche le build Docker avec le nouveau tag
# ============================================================================

name: CI/CD

# D√©clencheurs du workflow
on:
  push:
    tags: ['v*']  # S'ex√©cute sur tous les tags commen√ßant par 'v' (ex: v1.0.0)
    branches:
      - master  # Branche principale
      - dev     # Branche de d√©veloppement
      - '**'    # Toutes les autres branches (pattern glob)
  pull_request:
    types: [opened, synchronize, reopened, closed]  # Inclut 'closed' pour d√©tecter les merges

# Gestion de la concurrence pour √©viter les conflits
# Si plusieurs ex√©cutions du m√™me workflow sont d√©clench√©es sur la m√™me r√©f√©rence,
# annule les ex√©cutions pr√©c√©dentes encore en cours
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true  # Annule les ex√©cutions pr√©c√©dentes en cours

# Variables d'environnement globales utilis√©es par les jobs
env:
  REGISTRY: ghcr.io                    # Registry Docker GitHub Container Registry
  IMAGE_NAME: ${{ github.repository }} # Nom de l'image au format owner/repo

jobs:
  # ==========================================================================
  # JOB 1 : Compilation de l'application TypeScript
  # ==========================================================================
  # Appelle le workflow r√©utilisable build.yaml qui compile le code TypeScript
  # et g√©n√®re les fichiers JavaScript dans le dossier dist/
  build:
    name: Compilation
    uses: ./.github/workflows/build.yaml

  # ==========================================================================
  # JOB 2 : Tests et Couverture de Code
  # ==========================================================================
  # Appelle le workflow r√©utilisable test.yaml qui ex√©cute :
  # - Les tests unitaires
  # - Le linter (v√©rification du style de code)
  # - La g√©n√©ration du rapport de couverture de code
  # 
  # D√©pendance : Attend que le job 'build' soit termin√© avec succ√®s
  test:
    name: Tests et Couverture
    uses: ./.github/workflows/test.yaml
    needs: build  # Ne s'ex√©cute que si le build r√©ussit
    permissions:
      contents: write  # N√©cessaire pour publier les rapports sur GitHub Pages

  # ==========================================================================
  # JOB 3 : Versioning Automatique (uniquement si PR merged sur master)
  # ==========================================================================
  # D√©tecte les marqueurs v:MAJOR/MINOR/PATCH dans les commits et cr√©e
  # automatiquement un tag semver et une release GitHub
  versioning:
    name: Versioning Automatique
    runs-on: ubuntu-latest
    needs: test
    # Condition : Seulement si PR merged sur master ET marqueur d√©tect√©
    if: |
      github.event_name == 'pull_request' && 
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'master'
    
    permissions:
      contents: write        # N√©cessaire pour cr√©er des tags et des releases
      pull-requests: write   # N√©cessaire pour commenter sur les PRs
    
    outputs:
      new_tag: ${{ steps.calc.outputs.new_tag }}
      version_mode: ${{ steps.scan.outputs.mode }}
    
    steps:
      # R√©cup√©ration du code avec historique complet
      - name: R√©cup√©ration du code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      # R√©cup√©ration des tags
      - name: R√©cup√©ration des tags
        run: git fetch --tags --force

      # D√©termination du dernier tag
      - name: D√©terminer le dernier tag
        id: last
        run: |
          set -e
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
          
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="v0.0.0"
          fi
          
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "Dernier tag trouv√© : $LAST_TAG"

      # Scanner les commits pour les marqueurs
      - name: Scanner les commits pour les marqueurs de version
        id: scan
        run: |
          set -e
          LAST_TAG='${{ steps.last.outputs.last_tag }}'
          
          COMMITS=$(git log "$LAST_TAG"..HEAD --pretty=%B)
          
          echo "Commits entre $LAST_TAG et HEAD :"
          echo "$COMMITS"
          
          MODE=""
          
          if echo "$COMMITS" | grep -qi 'v:MAJOR'; then 
            MODE="MAJOR"
          fi
          
          if [ -z "$MODE" ] && echo "$COMMITS" | grep -qi 'v:MINOR'; then 
            MODE="MINOR"
          fi
          
          if [ -z "$MODE" ] && echo "$COMMITS" | grep -qi 'v:PATCH'; then 
            MODE="PATCH"
          fi
          
          echo "mode=$MODE" >> $GITHUB_OUTPUT
          
          if [ -z "$MODE" ]; then
            echo "‚ö†Ô∏è  Aucun marqueur v:MAJOR/MINOR/PATCH d√©tect√©. Pas de nouveau tag cr√©√©."
          else
            echo "‚úÖ Marqueur d√©tect√© : $MODE"
          fi

      # Calcul de la nouvelle version
      - name: Calcul de la nouvelle version
        id: calc
        if: steps.scan.outputs.mode != ''
        run: |
          set -e
          LAST_TAG='${{ steps.last.outputs.last_tag }}'
          MODE='${{ steps.scan.outputs.mode }}'
          
          PREFIX=""
          BASE="$LAST_TAG"
          
          if echo "$BASE" | grep -qE '^[^0-9]'; then
            PREFIX=$(echo "$BASE" | sed -E 's/^([^0-9]+).*$/\1/')
            BASE=$(echo "$BASE" | sed -E "s/^$PREFIX//")
          fi
          
          MAJOR=$(echo "$BASE" | cut -d'.' -f1)
          MINOR=$(echo "$BASE" | cut -d'.' -f2)
          PATCH=$(echo "$BASE" | cut -d'.' -f3 | sed 's/[^0-9].*$//')
          
          case "$MODE" in
            MAJOR)
              MAJOR=$((MAJOR+1))
              MINOR=0
              PATCH=0
              ;;
            MINOR)
              MINOR=$((MINOR+1))
              PATCH=0
              ;;
            PATCH)
              PATCH=$((PATCH+1))
              ;;
          esac
          
          NEW_TAG="${PREFIX}${MAJOR}.${MINOR}.${PATCH}"
          
          echo "‚úÖ Nouvelle version calcul√©e : $NEW_TAG (mode $MODE depuis $LAST_TAG)"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

      # Validation du format semver
      - name: Valider le format semver
        if: steps.calc.outputs.new_tag != ''
        run: |
          set -e
          NEW_TAG='${{ steps.calc.outputs.new_tag }}'
          
          if [[ ! "$NEW_TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "‚ùå ERREUR : Le tag calcul√© '$NEW_TAG' n'est pas au format semver valide !"
            echo ""
            echo "‚úÖ Exemples valides :"
            echo "   - v1.0.0"
            echo "   - v2.3.4"
            echo "   - v1.0.0-beta.1"
            echo "   - v1.2.3-rc.2"
            exit 1
          fi
          
          echo "‚úÖ Le tag '$NEW_TAG' est un semver valide"

      # Cr√©ation et publication du tag
      - name: Cr√©er et pousser le tag
        if: steps.calc.outputs.new_tag != ''
        run: |
          set -e
          NEW_TAG='${{ steps.calc.outputs.new_tag }}'
          
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin "$NEW_TAG"
          
          echo "‚úÖ Tag $NEW_TAG cr√©√© et pouss√© avec succ√®s."

      # Cr√©ation de la release GitHub
      - name: Cr√©er la release GitHub
        if: steps.calc.outputs.new_tag != ''
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.calc.outputs.new_tag }}
          name: Release ${{ steps.calc.outputs.new_tag }}
          generate_release_notes: true
          body: |
            üöÄ **Release g√©n√©r√©e automatiquement**
            
            **Type de mise √† jour :** ${{ steps.scan.outputs.mode }}
            **Version pr√©c√©dente :** ${{ steps.last.outputs.last_tag }}
            **Nouvelle version :** ${{ steps.calc.outputs.new_tag }}
            
            ---
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Commentaire sur la PR
      - name: Commenter la PR avec le nouveau tag
        if: steps.calc.outputs.new_tag != ''
        uses: actions/github-script@v8
        with:
          script: |
            const tag = '${{ steps.calc.outputs.new_tag }}';
            const mode = '${{ steps.scan.outputs.mode }}';
            
            await github.rest.issues.createComment({
              issue_number: context.payload.pull_request.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `üè∑Ô∏è **Tag automatique cr√©√© : \`${tag}\`**\n\n‚úÖ D√©tection du marqueur : **v:${mode}**\n\nUne release GitHub a √©t√© cr√©√©e automatiquement.\n\nüê≥ Le build Docker sera d√©clench√© automatiquement avec ce tag.`
            });

  # ==========================================================================
  # JOB 4 : Construction et Publication Docker
  # ==========================================================================
  # Appelle le workflow r√©utilisable docker.yaml qui construit l'image Docker
  # multi-architecture (amd64/arm64) et la publie sur GitHub Container Registry
  #
  # Conditions d'ex√©cution :
  # - Push sur master/dev/tags
  # - Apr√®s cr√©ation de tag par le job versioning
  #
  # D√©pendance : Attend que le job 'test' soit termin√© avec succ√®s
  # ET attend le job 'versioning' (qui peut √™tre skipped)
  docker:
    name: D√©ploiement
    uses: ./.github/workflows/docker.yaml
    needs: [test, versioning]
    # S'ex√©cute toujours si needs.versioning est skipped
    if: |
      always() &&
      needs.test.result == 'success' &&
      (needs.versioning.result == 'success' || needs.versioning.result == 'skipped') &&
      (
        (github.event_name == 'push' &&
         (github.ref == 'refs/heads/master' || 
          github.ref == 'refs/heads/dev' ||
          startsWith(github.ref, 'refs/tags/v'))) ||
        needs.versioning.outputs.new_tag != ''
      )
    
    permissions:
      contents: read   # N√©cessaire pour lire le code source
      packages: write  # N√©cessaire pour publier sur GitHub Container Registry
    
    secrets: inherit  # H√©rite des secrets du workflow appelant
