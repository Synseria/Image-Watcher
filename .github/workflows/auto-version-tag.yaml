# ============================================================================
# Workflow de Versioning Automatique
# ============================================================================
# Ce workflow automatise la cr√©ation de tags de version selon la convention
# Semantic Versioning (semver) bas√© sur des marqueurs dans les commits.
#
# Fonctionnement :
# 1. D√©tecte les marqueurs v:MAJOR, v:MINOR ou v:PATCH dans les commits
# 2. Calcule automatiquement la nouvelle version
# 3. Cr√©e et pousse un tag Git
# 4. Cr√©e une release GitHub
# 5. Commente sur la PR avec le nouveau tag
#
# Marqueurs √† utiliser dans les titres de commit ou PR :
# - v:MAJOR : changements incompatibles (1.2.3 ‚Üí 2.0.0)
# - v:MINOR : nouvelles fonctionnalit√©s (1.2.3 ‚Üí 1.3.0)
# - v:PATCH : corrections de bugs (1.2.3 ‚Üí 1.2.4)
# ============================================================================

name: Versioning Automatique

# D√©clenchement : lorsqu'une PR est fusionn√©e sur la branche master
on:
  pull_request:
    types: [closed]
    branches:
      - master

jobs:
  tag-version:
    # Condition : Ne s'ex√©cute que si la PR a √©t√© fusionn√©e (pas ferm√©e sans fusion)
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    
    permissions:
      contents: write  # N√©cessaire pour cr√©er des tags et des releases
    
    steps:
      # -----------------------------------------------------------------------
      # √âtape 1 : R√©cup√©ration du code source complet
      # -----------------------------------------------------------------------
      - name: R√©cup√©ration du code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # R√©cup√®re tout l'historique (n√©cessaire pour les tags)

      # -----------------------------------------------------------------------
      # √âtape 2 : R√©cup√©ration des tags
      # -----------------------------------------------------------------------
      # Force la r√©cup√©ration de tous les tags depuis le d√©p√¥t distant
      - name: R√©cup√©ration des tags
        run: git fetch --tags --force

      # -----------------------------------------------------------------------
      # √âtape 3 : D√©termination du dernier tag existant
      # -----------------------------------------------------------------------
      # Cherche le dernier tag de version. Si aucun tag n'existe, utilise
      # v0.0.0 comme point de d√©part
      - name: D√©terminer le dernier tag
        id: last
        run: |
          set -e
          # git describe --tags --abbrev=0 retourne le tag le plus r√©cent
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || true)
          
          if [ -z "$LAST_TAG" ]; then
            LAST_TAG="v0.0.0"  # Point de d√©part si aucun tag n'existe
          fi
          
          echo "last_tag=$LAST_TAG" >> $GITHUB_OUTPUT
          echo "Dernier tag trouv√© : $LAST_TAG"

      # -----------------------------------------------------------------------
      # √âtape 4 : Scanner les commits pour d√©tecter les marqueurs
      # -----------------------------------------------------------------------
      # Parcourt tous les commits entre le dernier tag et HEAD pour trouver
      # les marqueurs v:MAJOR, v:MINOR ou v:PATCH
      # Priorit√© : MAJOR > MINOR > PATCH (si plusieurs marqueurs, prend le plus √©lev√©)
      - name: Scanner les commits pour les marqueurs de version
        id: scan
        run: |
          set -e
          LAST_TAG='${{ steps.last.outputs.last_tag }}'
          
          # R√©cup√®re tous les messages de commit (titre + corps) depuis le dernier tag
          COMMITS=$(git log "$LAST_TAG"..HEAD --pretty=%B)
          
          echo "Commits entre $LAST_TAG et HEAD :"
          echo "$COMMITS"
          
          MODE=""  # MAJOR / MINOR / PATCH
          
          # D√©tection des marqueurs avec priorit√© (MAJOR > MINOR > PATCH)
          if echo "$COMMITS" | grep -qi 'v:MAJOR'; then 
            MODE="MAJOR"
          fi
          
          if [ -z "$MODE" ] && echo "$COMMITS" | grep -qi 'v:MINOR'; then 
            MODE="MINOR"
          fi
          
          if [ -z "$MODE" ] && echo "$COMMITS" | grep -qi 'v:PATCH'; then 
            MODE="PATCH"
          fi
          
          echo "mode=$MODE" >> $GITHUB_OUTPUT
          
          if [ -z "$MODE" ]; then
            echo "‚ö†Ô∏è  Aucun marqueur v:MAJOR/MINOR/PATCH d√©tect√©. Pas de nouveau tag cr√©√©."
          else
            echo "‚úÖ Marqueur d√©tect√© : $MODE"
          fi

      # -----------------------------------------------------------------------
      # √âtape 5 : Calcul de la nouvelle version
      # -----------------------------------------------------------------------
      # √Ä partir du dernier tag et du mode d√©tect√©, calcule la nouvelle version
      # en respectant les r√®gles semver :
      # - MAJOR : incr√©mente MAJOR, reset MINOR et PATCH √† 0
      # - MINOR : incr√©mente MINOR, reset PATCH √† 0
      # - PATCH : incr√©mente PATCH uniquement
      - name: Calcul de la nouvelle version
        id: calc
        if: steps.scan.outputs.mode != ''
        run: |
          set -e
          LAST_TAG='${{ steps.last.outputs.last_tag }}'
          MODE='${{ steps.scan.outputs.mode }}'
          
          # Extraction du pr√©fixe √©ventuel (ex: 'v' dans v1.0.0)
          PREFIX=""
          BASE="$LAST_TAG"
          
          if echo "$BASE" | grep -qE '^[^0-9]'; then
            PREFIX=$(echo "$BASE" | sed -E 's/^([^0-9]+).*$/\1/')
            BASE=$(echo "$BASE" | sed -E "s/^$PREFIX//")
          fi
          
          # Extraction des composants de version
          MAJOR=$(echo "$BASE" | cut -d'.' -f1)
          MINOR=$(echo "$BASE" | cut -d'.' -f2)
          PATCH=$(echo "$BASE" | cut -d'.' -f3 | sed 's/[^0-9].*$//')
          
          # Calcul de la nouvelle version selon le mode
          case "$MODE" in
            MAJOR)
              MAJOR=$((MAJOR+1))
              MINOR=0
              PATCH=0
              ;;
            MINOR)
              MINOR=$((MINOR+1))
              PATCH=0
              ;;
            PATCH)
              PATCH=$((PATCH+1))
              ;;
          esac
          
          # Reconstitution du tag avec le pr√©fixe
          NEW_TAG="${PREFIX}${MAJOR}.${MINOR}.${PATCH}"
          
          echo "‚úÖ Nouvelle version calcul√©e : $NEW_TAG (mode $MODE depuis $LAST_TAG)"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # √âtape 6 : Cr√©ation et publication du tag
      # -----------------------------------------------------------------------
      # Cr√©e un tag annot√© avec la nouvelle version et le pousse sur GitHub
      - name: Cr√©er et pousser le tag
        if: steps.calc.outputs.new_tag != ''
        run: |
          set -e
          NEW_TAG='${{ steps.calc.outputs.new_tag }}'
          
          # Configuration de l'identit√© Git pour cr√©er le tag
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          
          # Cr√©ation d'un tag annot√© (recommand√© pour les releases)
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          
          # Publication du tag sur GitHub
          git push origin "$NEW_TAG"
          
          echo "‚úÖ Tag $NEW_TAG cr√©√© et pouss√© avec succ√®s."

      # -----------------------------------------------------------------------
      # √âtape 7 : Cr√©ation de la release GitHub
      # -----------------------------------------------------------------------
      # Cr√©e automatiquement une release GitHub associ√©e au nouveau tag
      # avec des notes de release g√©n√©r√©es automatiquement
      - name: Cr√©er la release GitHub
        if: steps.calc.outputs.new_tag != ''
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.calc.outputs.new_tag }}
          name: Release ${{ steps.calc.outputs.new_tag }}
          body: |
            üöÄ Release g√©n√©r√©e automatiquement
            
            **Type de mise √† jour :** ${{ steps.scan.outputs.mode }}
            **Version pr√©c√©dente :** ${{ steps.last.outputs.last_tag }}
            **Nouvelle version :** ${{ steps.calc.outputs.new_tag }}
            
            Cette release a √©t√© cr√©√©e automatiquement suite √† la fusion d'une PR contenant le marqueur v:${{ steps.scan.outputs.mode }}.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # -----------------------------------------------------------------------
      # √âtape 8 : Commentaire sur la PR avec le nouveau tag
      # -----------------------------------------------------------------------
      # Poste un commentaire sur la PR fusionn√©e pour informer du tag cr√©√©
      - name: Commenter la PR avec le nouveau tag
        if: steps.calc.outputs.new_tag != ''
        uses: actions/github-script@v7
        with:
          script: |
            const tag = core.getInput('tag');
            const mode = '${{ steps.scan.outputs.mode }}';
            
            await github.rest.issues.createComment({
              issue_number: context.payload.pull_request.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `üè∑Ô∏è **Tag automatique cr√©√© : \`${tag}\`**\n\n‚úÖ D√©tection du marqueur : **v:${mode}**\n\nUne release GitHub a √©t√© cr√©√©e automatiquement.`
            });
        env:
          tag: ${{ steps.calc.outputs.new_tag }}

      # -----------------------------------------------------------------------
      # √âtape 9 : Log si aucun tag cr√©√©
      # -----------------------------------------------------------------------
      # Informe que aucun tag n'a √©t√© cr√©√© si aucun marqueur n'a √©t√© trouv√©
      - name: Aucun tag cr√©√©
        if: steps.scan.outputs.mode == ''
        run: echo "‚ÑπÔ∏è  Aucun tag g√©n√©r√© (aucun marqueur de version d√©tect√© dans les commits)."
